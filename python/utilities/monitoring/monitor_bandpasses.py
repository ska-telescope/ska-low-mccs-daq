# This script is meant to run in the background and intercepts integrated channelised data
# from a single station. The script does not control the data transmission, it just listed
# wait for incoming data. An instance of this script is meant to be associated with a single
# station. This means that different data streams need to be transmitted to different
# ports. This port is defined in the provided configuration file for the station
#!/usr/bin/env python2

from pydaq import daq_receiver as receiver
from pyaavs import station

from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer
from multiprocessing import Process
from math import floor
from time import sleep
import numpy as np
import threading
import datetime
import tempfile
import logging
import pexpect
import signal
import shutil
import h5py
import sys
import os
import re

try:
    from aavs_calibration.common import *
except:
    pass


# Global parameters
nof_antennas_per_tile = 16
nof_channels = 512
bandwidth = 400.0
nof_pols = 2

# Global store containing files to be processed
antenna_locations = {}
stop_bandpass = False
files_to_plot = {}


def _signal_handler(signum, frame):
    global stop_bandpass
    # Stop observer and data acqusition
    logging.info("Received interrupt, stopping bandpass generation")
    stop_bandpass = True


def signed(data, bits=8, ext_bits=8):
    """ Return signed data"""
    data = data % 2**bits
    if data >= 2**(bits-1):
        data -= 2**bits
    if ext_bits > bits:
        if data == -2**(bits-1):
            data = -2**(ext_bits-1)
    return data


def monitor_delays(frequency, reference_antenna, test_antenna, reference_pol, test_pol, cadence):
    """ Monitor delay through fibre loopback 
    :param frequency: Frequency where signal will be
    :param reference_antenna: Antenna where reference signal is
    :param test_antenna: Antenna where looped back signal is
    :param reference_pol: Pol where reference signal is
    :param test_pol: Pol where looped back signal is
    :param cadence: Period at which to measure delay """
    global stop_bandpass

    # Import Mongo model here (after fork)
    from aavs_calibration.models import FibreDelay

    config_path = "/opt/aavs/config/uk_phase0.yml"
    station.load_configuration_file(config_path)
    station_conf = station.configuration

    user = 'pi'
    password = 'raspberry'
    host = 'rasp-pi'
    command = "'./syncbox.py --reference=external --freq={} --save'"

    def _change_frequency(frequency):
        """ Change frequency generated by signal generator 
        :param frequency: frequency in MHz"""

        freq_command = command.format(frequency)
        child = pexpect.spawn('ssh %s@%s %s' % (user, host, freq_command), logfile=sys.stdout, timeout=None)
        prompt = child.expect(['password:', r"yes/no", pexpect.EOF])
        if prompt == 0:
                child.sendline(password)
        elif prompt == 1:
                child.sendline("yes")
                child.expect("password:", timeout=30)
                child.sendline(password)
        data = child.read()
        child.close()

    # Identify FPGAs
    if reference_antenna < 8:
        input_0_ptr = 2*reference_antenna + reference_pol
        reference_fpga = 'fpga1'
    else:
        input_0_ptr = 2*(reference_antenna-8) + reference_pol
        reference_fpga = 'fpga2'
    if test_antenna < 8:
        input_1_ptr = 2*test_antenna + test_pol
        test_fpga = 'fpga1'
    else:
        input_1_ptr = 2*(test_antenna-8) + test_pol
        test_fpga = 'fpga2'

    if reference_fpga != test_fpga:
        logging.error("Error! Signals must be connected to the same FPGA!")
        return

    # Define readout register pointer
    channel = int(floor(frequency / (400 / 512.0)))
    readout_ptr_register = (channel << 16) + (input_1_ptr << 8) + input_0_ptr
    logging.info("Delay measurement using channel {}".format(channel))

    # Create and connect to station
    delay_station = station.Station(station_conf)
    delay_station.connect()

    def _connect_station():
        """ Return a connected station """

        # Connect to station and see if properly formed
        while True:
            try:
                # Check that station is well formed
                delay_station.check_station_status()
                if not delay_station.properly_formed_station:
                    raise Exception
                else:
                    break
            except Exception as e:
                sleep(60) 
                try:
                    delay_station.connect()
                except:
                    continue

    # Perform multiple readings for each period and use the median
    repeated_readings = 10

    # Continue until asked to stop
    while not stop_bandpass:

        # Check station status
        _connect_station()

        # Get five readings
        phase_diffs = np.zeros(repeated_readings)
        for counter in range(repeated_readings):

            delay_station['%s.lmc_gen.readout_channel_ptr' % reference_fpga] = 0x00000000 + readout_ptr_register
            sleep(0.1)

            # Get values
            reference_value = signed((delay_station['%s.lmc_gen.readout_input_0' % reference_fpga][0]  & 0xFFF), 12) +           \
                              signed(((delay_station['%s.lmc_gen.readout_input_0' % reference_fpga][0] >> 12) & 0xFFF), 12)*1j
            test_value =      signed((delay_station['%s.lmc_gen.readout_input_1' % test_fpga][0]       & 0xFFF), 12) +           \
                              signed(((delay_station['%s.lmc_gen.readout_input_1' % test_fpga][0]      >> 12) & 0xFFF), 12)*1j

            delay_station['%s.lmc_gen.readout_channel_ptr' % reference_fpga] = 0x30000000 + readout_ptr_register

            # Calculate phase difference
            a0 = np.angle(reference_value)
            a1 = np.angle(test_value)
            phase_diffs[counter] = np.rad2deg(np.arctan2(np.sin(a0-a1), np.cos(a0-a1)))

        # Save the median to the database
        new_delay = FibreDelay(frequency=frequency, delay=np.median(phase_diffs), measurement_time=datetime.now())
        new_delay.save()

        # Sleep for a while
        sleep(cadence)


def plotting_thread_function(plotting_directory, station_name):
    """ Plotting thread function"""
    global files_to_plot
    global stop_bandpass

    # Import and setup matplotlib
    from matplotlib.backends.backend_svg import FigureCanvasSVG as FigureCanvas
    from matplotlib.figure import Figure
    import matplotlib.colors as colors

    _directory = plotting_directory
    _freq_range = np.arange(1, nof_channels) * (bandwidth / nof_channels)
    _filename_expression = re.compile(r"channel_integ_(?P<tile>\d+)_(?P<timestamp>\d+_\d+)_0.hdf5")

    # Define fibre - antenna mapping
    _fibre_preadu_mapping = {0: 1, 1: 2, 2: 3, 3: 4,
                             7: 13, 6: 14, 5: 15, 4: 16,
                             8: 5, 9: 6, 10: 7, 11: 8,
                             15: 9, 14: 10, 13: 11, 12: 12}

    # Define plotting parameters
    _ribbon_color = {1: 'gray', 2: 'g', 3: 'r', 4: 'k',
                     5: 'y', 6: 'm', 7: 'deeppink', 8: 'c',
                     9: 'gray', 10: 'g', 11: 'r', 12: 'k',
                     13: 'y', 14: 'm', 15: 'deeppink', 16: 'c'}
    _pol_map = ['X', 'Y']

    # Set up figure and initialise with dummy data
    plot_lines = []
    fig = Figure(figsize=(8, 4))
    canvas = FigureCanvas(fig)
    ax = fig.add_subplot(111)

    for antenna in range(nof_antennas_per_tile):
        tpm_input = _fibre_preadu_mapping[antenna]
        plot_lines.append(ax.plot(_freq_range,
                          range(511),
                          label="Antenna {} (RX {})".format(antenna, tpm_input),
                          color=_ribbon_color[tpm_input],
                          linewidth=0.6)[0])

    # Extarct antenna locations
    antenna_base, _, _ = antenna_locations[station_name]

    # Make nice
    ax.set_xlim((0, bandwidth))
    ax.set_ylim((0, 40))
    ax.set_title("Tile {} - Pol {}".format(0, _pol_map[0]), fontdict={'fontweight':'bold'})
    ax.set_xlabel("Frequency (MHz)")
    ax.set_ylabel("Power (dB)")
    date_text = ax.text(300, 38, "Dummy date", weight='bold', size='10')
    legend = ax.legend(loc="lower center", ncol=4, prop={'size': 4})
    ax.minorticks_on()
    ax.grid(b=True, which='major', color='0.3', linestyle='-', linewidth=0.5)
    ax.grid(b=True, which='minor', color='0.8', linestyle='--', linewidth=0.1)

    # Loop until asked to stop
    while not stop_bandpass:
        # Wait for files to be queued
        while len(files_to_plot[station_name]) == 0 and not stop_bandpass:
            sleep(0.1)
        
        if stop_bandpass:
            return

        # Get the first item in the list
        filepath = files_to_plot[station_name].pop(0)
        logging.info("Processing {}".format(filepath))

        # Extract Tile number
        filename = os.path.basename(os.path.abspath(filepath))
        parts = _filename_expression.match(filename)
        tile_number = int(parts.groupdict()['tile'])

        # Open newly create HDF5 file
        with h5py.File(filepath, 'r') as f:
            # Data is in channels/antennas/pols order
            data = f['chan_']['data'][:]
            timestamp = f['sample_timestamps']['data'][0]
            data = data.reshape((nof_channels, nof_antennas_per_tile, nof_pols))

            # Convert to power in dB
            np.seterr(divide='ignore')
            data = 10 * np.log10(data)
            data[np.isneginf(data)] = 0
            np.seterr(divide='warn')

        # Format datetime
        date_time = datetime.utcfromtimestamp(timestamp).strftime("%y-%m-%d %H:%M:%S")

        # Loop over polarisations (separate plots)
        for pol in range(nof_pols):

            # Loop over antennas, change plot data and label text
            for i, antenna in enumerate(range(nof_antennas_per_tile)):
                plot_lines[i].set_ydata(data[1:, antenna, pol])
                legend.get_texts()[i].set_text("{:0>2d} - RX {:0>2d} - Base {:0>3d}".format(i, _fibre_preadu_mapping[antenna],
                                                                                            antenna_base[tile_number * 16 + i]))
                
            # Update title and time
            ax.set_title("Tile {} - Pol {}".format(tile_number + 1, _pol_map[pol]))
            date_text.set_text(date_time)

            # Save updated figure
            canvas.print_figure(os.path.join(_directory, 
                        "tile_{}_pol_{}.svg".format(tile_number + 1, _pol_map[pol].lower())), 
                        pad_inches=0, dpi=200, figsize=(8, 4))
            
        # Ready from file, delete it
        os.unlink(filepath)


def generate_rms_plots(config, directory):
    """ Generate RMS plots
    :param config: Station configuration file """
    global antenna_locations
    global stop_bandpass

    # Import and setup matplotlib
    from matplotlib.backends.backend_svg import FigureCanvasSVG as FigureCanvas
    from matplotlib.figure import Figure
    import matplotlib.colors as colors

    def _connect_station():
        """ Return a connected station """
        # Connect to station and see if properly formed
        while True:
            try:
                aavs_station.check_station_status()
                if not aavs_station.properly_formed_station:
                    raise Exception
                break
            except:
                sleep(60) 
                try:
                    aavs_station.connect()
                except:
                    continue

    # Create and connect to station
    aavs_station = station.Station(config)
    station_name = aavs_station.configuration['station']['name']
    _connect_station()

    # Extarct antenna locations
    antenna_base, antenna_x, antenna_y = antenna_locations[station_name]

    # Generate dummy RMS data
    colors = np.random.random(len(antenna_x)) * 30

    # Generate figure and canvas
    fig = Figure(figsize=(18, 8))
    canvas = FigureCanvas(fig)

    # Generate plot for X
    ax = fig.subplots(nrows=1, ncols=2, sharex='all', sharey='all')
    fig.suptitle("{} Antenna RMS".format(station_name), fontsize=14)

    x_scatter = ax[0].scatter(antenna_x, antenna_y, s=50, marker='o', c=colors, cmap='jet', vmin=0, vmax=38, edgecolors='k', linewidths=0.8)
    for i in range(len(antenna_x)):
        ax[0].text(antenna_x[i] + 0.3, antenna_y[i] + 0.3, antenna_base[i], fontsize=7)
    ax[0].set_title("{} Antenna RMS Map - X pol".format(station_name))
    ax[0].set_xlabel("X")
    ax[0].set_ylabel("Y")

    # Generate plot for Y
    y_scatter = ax[1].scatter(antenna_x, antenna_y, s=50, marker='o', c=colors, cmap='jet', vmin=0, vmax=38, edgecolors='k', linewidths=0.8)
    for i in range(len(antenna_x)):
        ax[1].text(antenna_x[i] + 0.3, antenna_y[i] + 0.3, antenna_base[i], fontsize=7)
    ax[1].set_title("{} Antenna RMS Map - Y Pol".format(station_name))
    ax[1].set_xlabel("X")
    ax[1].set_ylabel("Y")

    # Add colorbar
    fig.subplots_adjust(bottom=0.1, top=0.9, left=0.1, right=0.88,
                        wspace=0.05, hspace=0.17)
    cb_ax = fig.add_axes([0.9, 0.1, 0.02, 0.8])
    fig.colorbar(y_scatter, label="RMS", cax=cb_ax)

    # Continue until asked to stop
    while not stop_bandpass:

        # Check station status
        _connect_station()

        # Grab RMS values
        antenna_rms_x = []
        antenna_rms_y = []
        for tile in aavs_station.tiles:
            rms = tile.get_adc_rms()
            antenna_rms_x.extend(rms[0::2])
            antenna_rms_y.extend(rms[1::2])

        # Update colors
        x_scatter.set_array(np.array(antenna_rms_x))
        y_scatter.set_array(np.array(antenna_rms_y))

        # Save plot
        fig.suptitle("{} Antenna RMS ({})".format(station_name, datetime.utcnow().strftime("%m/%d/%Y %H:%M:%S")), fontsize=14)
        canvas.print_figure(os.path.join(directory, "antenna_rms.svg"), pad_inches=0, dpi=200, figsize=(18, 8))

        # Done, sleep for a bit
        sleep(60)


class IntegratedDataHandler(FileSystemEventHandler):
    """ Detects file created in the data directory and generates plots """

    def __init__(self, station_name):
        """ Constructor
        :param station_name: Station name """
        self._station_name = station_name
        files_to_plot[station_name] = []

    def on_any_event(self, event):
        # We are only interested in newly created files
        global files_to_plot

        if event.event_type == 'created':

            # Ignore lock files and other temporary files
            if not ("channel" in event.src_path and not "lock" in event.src_path):
                return

            # Add to list
            sleep(0.1)
            logging.info("Detected {}".format(event.src_path))
            files_to_plot[self._station_name].append(event.src_path)
            

def configure_data_acquisition(interface, port, nof_tiles, directory):
    """ Start the DAQ instance for this station
    :param interface: Network interface
    :param port: Network port
    :param nof_tiles: Number of tiles in station
    :param directory: Directory where data will temporarily be stored"""

    # DAQ configuration
    daq_config = {"receiver_interface": interface,
                  "receiver_ports": str(port),
                  "nof_tiles": nof_tiles,
                  'directory': directory,
                  "append_integrated": False}

    # Turn off logging in DAQ
    receiver.LOG = False

    receiver.populate_configuration(daq_config)
    receiver.initialise_daq()
    receiver.start_integrated_channel_data_consumer()


def create_plotting_directory(parent, station_name):
    """ Create plotting directory structure for this station
    :param parent: Parent plotting directory
    :param station_name: Station name """
    # Check if plot directory exists and if not create it
    if not os.path.exists(parent):
        try:
            os.mkdir(parent)
        except:
            logging.error("Could not create plotting directory {}. "
                          "Check that the path is valid and permission".format(parent))
            return False
    elif os.path.isdir(parent):
        if not os.path.exists(os.path.join(parent, station_name)):
            try:
                os.mkdir(os.path.join(parent, station_name))
            except:
                logging.error("Could not plotting subdirectory for {} in {}. "
                              "Please check".format(parent, station_name))
                return False
    else:
        logging.error("Specified plotting directory ({}) is a file. Please check".format(parent))
        return False

    return True

def bandpass_monitor(config_path, plot_directory, interface, monitor_rms=False):
    """ Entry point to a bandpass monitoring process instance
    :param config_path: Path to station configuration file
    :param plot_directory: Plotting directory
    :param interface: Interface for receiving monitoring data
    :param monitor_rms: Flag to enable or disable RMS monitoring """
    global antenna_locations
    global stop_bandpass

    # Load configuration file
    station.load_configuration_file(config_path)
    station_conf = station.configuration

    # Extract station name
    station_name = station_conf['station']['name']
    if station_name.upper() == "UNNAMED":
        logging.error("Please set station name in configuration file {}, currently unnamed".format(config_path))
        exit()

    # Check that the station is configured to transmit data over 1G
    if station_conf['network']['lmc']['use_teng_integrated']:
        logging.warning("Station {} must be configured to send integrated data over the 1G network, "
                        "and each station should define a different destination port. Please check".format(config_path))
        exit()

    # Get and store antenna positions
    antenna_locations[station_name] = get_antenna_positions(station_name)

    # Create plotting directory structure
    if not create_plotting_directory(opts.plot_directory, station_name):
        exit()

    # Create data directory
    data_directory = tempfile.mkdtemp()
    logging.info("Using temp dir {}".format(data_directory))

    # Configure DAQ
    configure_data_acquisition(opts.interface,
                               station_conf['network']['lmc']['integrated_data_port'],
                               len(station_conf['tiles']),
                               data_directory)

    # Start rms thread
    rms = Process(target=generate_rms_plots, args=(station_conf, os.path.join(opts.plot_directory, station_name)))
    rms.start()

    # Start directory monitor
    observer = Observer()
    data_handler = IntegratedDataHandler(station_name)
    observer.schedule(data_handler, data_directory)
    observer.start()
    
    # Start plotting thread
    plotting_thread = threading.Thread(target=plotting_thread_function,
                                       args=(os.path.join(opts.plot_directory, station_name), station_name))
    plotting_thread.start()
    
    # Wait for stop, monitoring disk space in the meantime
    while not stop_bandpass:
        dir_size = sum(os.path.getsize(f) for f in os.listdir(data_directory) if os.path.isfile(f))
        if dir_size > 200 * 1024 * 1024:
            logging.error("Consuming too much disk space! Exiting")
            stop_bandpass = True
            break
        sleep(5)
    
    # Stop and clean up
    logging.info("Waiting for threads and processes to terminate")
    receiver.stop_daq()
    observer.stop()
    shutil.rmtree(data_directory, ignore_errors=True)
    observer.join()
    plotting_thread.join()


if __name__ == "__main__":
    from optparse import OptionParser
    from sys import argv, stdout

    parser = OptionParser(usage="usage: %monitor_bandpasses [options]")
    parser.add_option("--config", action="store", dest="config",
                      default="/opt/aavs/config/eda2_full_delayperant.yml,/opt/aavs/config/aavs2.yml",
                      help="Station configuration files to use, comma-separated (default:EDA2, AAVS2)")
    parser.add_option("--plot_directory", action="store", dest="plot_directory",
                      default="/storage/monitoring/bandpass",
                      help="Directory where plots will be generated (default: /storage/monitoring/bandpass)")
    parser.add_option("--interface", action="store", dest="interface",
                      default="eth3", help="Network interface (default: eth3)")
    parser.add_option("--start-delay-monitor", action="store_true", dest="start_delay",
                      default=False, help="Start delay monitoring (default: False)")

    (opts, args) = parser.parse_args(argv[1:])

    # Set logging
    log = logging.getLogger('')
    log.setLevel(logging.INFO)
    line_format = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    ch = logging.FileHandler(filename="/opt/aavs/log/bandpasses", mode='w')
    ch.setFormatter(line_format)
    log.addHandler(ch)

    # Check if a configuration file was defined
    if opts.config is None:
        log.error("A station configuration file is required, exiting")
        exit()
    else:
        for config_path in opts.config.split(','):
            if not os.path.exists(config_path):
                log.error("Station configuration file {} is invalid, exiting".format(config_path))
                exit() 

    # Wait for exit or termination
    signal.signal(signal.SIGINT, _signal_handler)

    # If monitoring delays, start it in a separate process
    delay_process = None
    if opts.start_delay:
        logging.info("Starting delay monitor")
        delay_process = Process(target=monitor_delays, args=(191.875, 0, 1, 0, 0, 10))
        delay_process.start()

    # Create a process for each config file
    processes = []
    for config_path in opts.config.split(','):
        process = Process(target=bandpass_monitor, args=(config_path, opts.plot_directory, opts.interface))
        process.start()

    # Wait for stop
    while not stop_bandpass:
        sleep(1)

    # Stop delay_process
    if delay_process is not None:
        delay_process.join()

    # Wait for processes to exit
    for p in processes:
        p.join()
    
